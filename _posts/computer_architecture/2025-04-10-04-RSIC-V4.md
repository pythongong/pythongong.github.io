---
layout: post
title:  "RSIC-V(4): Calling Instructions & Conventions"
date:   2025-04-10
tag: Computer Architecture
---

During a function call:

● Keep local scope separate from global scope

● Perform the desired task of the function 

Returning from a function:

● Place the return value in a variable that can be accessed

● Go to the line immediately after the function call

The code generated by the compiler must implement some protocols for passing parameters and control from calling function to called function and back. Here is a simple protocol for a single C function:

Calling a function:

1. The caller pushes space onto the stack for the parameters to the call.
2. The caller copies the values function parameters into the register a0-a9 or save the values on the stack if necessary.
3. The caller saves state on the tack and  return address after call exits. 
4. Go to the start address of the function


Some optimizing compilers have schemes where some parameters are passed in registers instead of through the stack, but we’ll ignore that option for now. To make operations fast, several registers are devoted to various execution housekeeping needs. The **SP** register is dedicated to holding the address of the top of the stack. The **PC** register is a programming counter and the **RV** register will be used to communicate return value from a function. 

In our protocol, the parameters will be pushed on the stack in **right-to-left order**, followed by the saved return address and then the local variables in **top-to-bottom** order. We’ll assume that the return value won’t be placed on the stack , but instead be written in the RV register. This won’t allow return values that are larger than the word size of the machine. This is an example.

In RISC-V, local scope doesn't exist; all registers are "kept" throughout the program. If a function changes register x10, then the global value of x10 will also change. This can be solved if we treat the return address as an input to the function.  A special 33rd register called the **Program Counter** (or PC) keeps track of which line of code is currently being run.  The address of an instruction can be used (along with the PC) to perform the jumps we need for functions.

Jumps to the given label, but also sets x1 to PC+4 , which is the address of the line after the current line. 

```bash
jal x1 Label:
```

If the address of current instruction is 0x0000 0008,  x1 will be set to 0x0000 000C, and PC will move to Label.

Jumps to the instruction at address x1+4, and sets x2 to PC+4. It’s less common than other jumps, but used for higher-order functions and some function calls. 

```bash
jalr x2 x1 4:
```

Jumps to the instruction at address x1. It’s often used to return from a function

```bash
jr x1:
```

It’s also a pseudo-instruction for 

```bash
jalr x0 rs1 0
```

In RISC-V, one of our registers (by convention x2, nicknamed sp, or "stack pointer") is set to the bottom of the stack. A function can choose to create a stack frame, by manipulating sp.  Anything above the sp at the start of a function belongs to another function. You may not modify anything above the sp without permission. Everything below the sp is safe to modify. But anyone else can modify it, so you can't leave data there and expect it to stay the same. By decrementing the sp, we can allocate as much space as we need for our function, that we can use however we want.  After finishing a function call, the sp must be set to its value from before the function call.

Each register is given a name according to what its role is (no need to memorize the exact mapping):

● zero: The x0 register, which always stores 0

● ra: x1, which is used to store return addresses

Two new pseudo-instructions that explicitly use this:

```bash
jal Label -> jal ra Label

ret -> jr ra
```

Callee Saved registers: Registers that must be restored by the end of a function call (i.e. if you want to use it, the called function needs to save the old value)

● sp: The x2 register, which is the stack pointer

● s0-s11: Saved registers

Caller Saved registers: Registers that do not need to be restored by a called function (i.e. if you want to save a variable in this register, it needs to be saved somewhere before you call another function)

● ra: register for return value

● a0-a7: Registers used for function arguments. a0, a1 also used for function outputs. If a function needs more than 8 arguments, can use the stack to store more arguments

● t0-t6: Temporary Registers

For example 

```bash
......
addi sp, sp, -4 # allocate memory for the registers
sw t0, 0(sp) # save the register
jal print
lw t0, 0(sp) # restore the register
addi sp, sp, 4 # 
......
```

Instructions `ebreak, ecall` are the environment break/call . Asks the computer to do something (ex. Print data, set a breakpoint for debugging, allocate heap space). 

If you don’t need to call other functions, you can use the temporary registers as many as you can. But if you need to call other functions, you should use the saved registers for data used in many places. For example, you store the heap pointer in a saved register, then you don’t need to save it when calling other functions. At the end, you can free it by the saved register. 

If  you need to call other functions, you must save the return register, as calling will update the value of the return register automatically.

```bash
addi sp, sp, -4 # allocate memory for the registers
sw ra, 0(sp) # save the register



lw ra, 0(sp) # restore the register
addi sp, sp, 4 # 
```

The distinction between a block of code and a function is whether you use the return register.

```bash

Error:
	li a0 30

Success:
	li a0 0
	jr ra
```

The code under the `Error` label contains just a block of instructions. After executing these instructions, it will execute the instruction under the `Success` label.